#!/bin/bash
## run the necessary things for pssh2 predictions
### run and parse hhblits

if [ -z "$conf_file" ]; then
	conf_file='/etc/pssh2.conf'
fi

### base path to cache
pssh2_cache="/mnt/project/psshcache/result_cache_2014/"
### work directory
temp_work="/tmp/pssh2"
### table to store pssh2 calculation status in
status_table="pssh2_active_counts"
### table to store pssh2 calculation results in
table_name="pssh2_active"
### data kept on the local file system
local_data="/var/tmp/rost_db/data/"

seqfile='query.fasta' 
hhblitsLog='hhblits.log' 
a3mfile='query.uniprot20.a3m' 
hmmfile='query.uniprot20.hhm' 
hhrfile='query.uniprot20.hhr'
pdbhhrfile='query.uniprot20.pdb.full.hhr'

# get configurable options, e.g. local file paths
if [ -s $conf_file ]
then
	source $conf_file
fi

# in case some of these parameters were changed in the conf_file
# we better set the dependent parameters here
logfile=$seqfile.$hhblitsLog
a3mfile_gz=$a3mfile.gz


# by default we want to use the system installation
# but if local_paths is set we have the option to change the path and instead use the local variants
if [ $local_paths ]
then
	PATH=$local_paths:$PATH
	export PATH
	echo "Using path: $PATH"
fi


usage()
{
cat << EOT
NAME
  pssh2_seq - generate pssh2 type sequence-to-structrue alignments 
SYNOPSIS
  pssh2_seq [-s] [-h] [-D] [-F 0|1|2] [-R] [-t tableName] [-- ...]
DESCRIPTION
  pssh2_seq takes an input sequence (query.fasta) and generates sequence-to-structure 
  alignments for this sequence. 
  To this end, it starts the two subsequent HHblits runs:
  1) build_hhblits_profile: search against uniprot20 database of HMMs and generate a 
      HHM output (HMM-profile)
  2) scan_structures_hhblits: starting with the HHM output from step 1,
      search against the pdb_full database of HMMs and generate a HHR ouput
  Subsequently, it parses the HHR output from the second run using the 
  "parse_hhr_for_pssh2" perl script and generates a .pssh2 file.
  Finally, this outputfile is read into the MySQL database pssh2_local, table $table_name, 
  using "DB.pssh2_local" to retrieve the access parameters.
  The table $status_table keeps track of the generation date of the data, the 
  runtime and the number of hits found for the sequence. Negative count number indicate 
  error states:
    -1 -> build_hhblits_profile, -2 -> scan_structures_hhblits, -3 -> parse_hhr_for_pssh2, 
    -99 -> sequence not found
  Any input not mentioned in options is passed on to 1) and 2). 
  The databases to search with hhblits should be available under $local_data
  unless they are explicitly given in the input.
  Defaults are configured in $conf_file.
OPTIONS
  -h          The option -h displays help and exits.
  -D          Debug option: do not remove or zip output files
  -F n        Set force remaking status for making of HMM profile (run build_hhblits_profile):
     0           do not make profile unless none exists
     1           run only if the profile is older than the last update of uniprot20 (default)
     2           always run, even if the profile exists 
  -R          Retain (DO NOT remake) the HMM profile (same as -F 0)
  -t          use tableName for storing the pssh2 output in the mysql database (default: $table_name)
  -s          Operate silently (passed on to the child scripts.)
  Any other parameters behind "--" are passed on to the child scripts.
AUTHOR
  Andrea Schafferhans <andrea.schafferhans@rostlab.org>
EOT
}

force=1
debug=0
silent=0
passOpt=" " 
while getopts :sDF:Rht: opt
do
	case $opt in
#	D) echo -e "debug mode: do not change output files \n"; debug=1;;
#	F) echo -e "force mode: remake the HMM profile  \n"; force=1;;
#	R) echo -e "reuse mode: no not remake the HMM profile  \n"; force=0;;
	D) debug=1;;
	F) force=$OPTARG;;
	R) force=0;;
	t) table_name=$OPTARG;;
	h) usage; exit;;
	s) silent=1; passOpt="$passOpt -$opt";;
	:)  echo "Error: -$OPTARG requires an argument"; usage; exit 1;;
#	*) passOpt="$passOpt -$opt";;
	esac
done

if [ $debug -eq 1 ]
then
	set -x
fi

shift $(expr $OPTIND - 1 )
passOpt="$passOpt $@"

fail=0
skip=0
 
if [ $force -le 1 ] 
then
	# check whether we already have a uniprot20 hmm
	if [ -s $hmmfile ] 
	then
		hmm_stamp=`stat -c%Y $hmmfile`
	    if [ $force -eq 1 ] 
	    then
			db_stamp=`DB.pssh2_local "select last_update_stamp from database_status where name='uniprot20' order by last_update_stamp" | tail -1`
			if [ $hmm_stamp -gt $db_stamp ]
			then
		    	skip=1
		    fi
		else
			skip=1
		fi
    	if [ $silent -eq 0 ]
    	then
	    	echo "HMM already made: $hmm_stamp in "
	    	pwd
			if [ $skip -eq 1 ] 
			then
				echo "file will be used again"
			else
				echo "file will be remade"
			fi
		fi
	fi
fi

if [ $skip -eq 0 ] 
then
#	time nice build_hhblits_profile -f  query.fasta -m  $hmmfile -a query.uniprot20.a3m -r query.uniprot20.hhr $passOpt
	time build_hhblits_profile -f  $seqfile -m  $hmmfile -a $a3mfile -r $hhrfile $passOpt
else 
    if [ $silent -eq 0 ]
    then
		echo "skip making HMM."
	fi
fi

if [ -s query.uniprot20.hhm ] 
then
# 	time nice scan_structures_hhblits -m  $hmmfile -r query.uniprot20.pdb.full.hhr $passOpt
 	time scan_structures_hhblits -m  $hmmfile -r query.uniprot20.pdb.full.hhr $passOpt
else
	fail=-1
fi
 
if [ -s query.uniprot20.pdb.full.hhr ]
then
 	time nice parse_hhr_for_pssh2 -i  query.uniprot20.pdb.full.hhr -s  query.fasta -o query.pssh2
elif [ $fail -eq 0 ]
then
 	fail=-2	
fi
	
runtime=$SECONDS

### add output to the db
s=`date +%s`
md5=`cat query.fasta | fasta_to_md5`
if [ -s query.pssh2 ] 
then
	DB.pssh2_local "load data local infile 'query.pssh2' IGNORE INTO TABLE $table_name columns terminated by ',' (protein_sequence_hash,PDB_chain_hash,Repeat_domains,E_value,@var_id_score,Alignment) set Identity_Score=@var_id_score*100 "
 	n=`cat query.pssh2 |wc -l`
 	DB.pssh2_local "insert into $status_table set md5=\"$md5\" , count=$n , stamp=$s , runtime=$runtime ON DUPLICATE KEY UPDATE count=$n , stamp=$s , runtime=$runtime "
else
	if [ $fail -eq 0 ]
 	then
 		fail=-3
 	fi
 	DB.pssh2_local "insert into $status_table set md5=\"$md5\" , count=$fail , stamp=$s , runtime=$runtime ON DUPLICATE KEY UPDATE count=$fail , stamp=$s, runtime=$runtime " 		
fi
  
### compress things / delete
if [ $debug -eq 0 ]
then
	if [ -s query.uniprot20.a3m ] 
	then
		gzip query.uniprot20.a3m  
	fi	
	if [ -s query.fasta.hhblits.log ]
	then
		rm query.fasta.hhblits.log
	fi
	if [ -s query.uniprot20.hhm.hhblits.log ]
	then
		rm query.uniprot20.hhm.hhblits.log
	fi
	if [ -s query.uniprot20.hhr ]
	then
	 	gzip -f query.uniprot20.hhr
	fi
 	gzip -f query.uniprot20.pdb.full.hhr
# 	gzip query.pssh2
fi